#!/usr/bin/env python3
'''A script for converting vac .dat data files to .fits

Steps
1) convert .dat to .blk with amrvac itself
2) convert .blk to .fits.gz
    a) sort the raw data points (original order is messy)
    b) reshape to 2D numpy arrays
    c) interpolate data to fit a MCFOST grid (log-spacing)
    d) convert to 3D (gaussian redistribution of density)
    e) unit conversion                                    <<<<< NOT IMPLEMENTED YET


Arguments
-c configuration file for this script
-d .dat file to be converted


Known limitations
   1) amr is not supported
   2) portability is not guaranted
   3) gaussian redistribution is currently unreliable (hard coded parameters)
   4) interpolation does not account for the curvature of polar cells
   5) a cylindrical grid is currently used for 3D,
      we may later implement the spherical option
   6) input simulation is assumed to be 2D (r,phi)
   7) gas density not being read yet
   8) when dust density is available, gas density is being ignored.
      That needs fixing if we wish to generate molecular lines synthetic observations.
'''

import pathlib
import shutil
import subprocess
from argparse import ArgumentParser
from warnings import warn

import numpy as np
import astropy.io.fits as pyfits
from scipy.interpolate import interp2d
import f90nml

from amrvac_pywrap import amrvac_convert

try:
    res = subprocess.check_output('which mcfost', shell=True).decode('utf-8')
    assert not 'not found' in res
except AssertionError:
    raise EnvironmentError('Installation of MCFOST not found.')


def sort_raw_data(block:np.array, nr:int, nphi:int) -> np.ndarray:
    '''Sort the block data lines along phi then r'''
    slicer  = block[:,1].argsort()
    block_s = block[slicer] #sort along phi
    for i in range(nphi):
        #second sort along r
        m_block = block_s[i*nr:(i+1)*nr]
        m_block = m_block[m_block[:,0].argsort()]
        block_s[i*nr:(i+1)*nr] = m_block
    return block_s

def unique_sorted_list(arr:list):
    return sorted(list(set((arr))))

def gauss(z, sigma):
    return 1./(np.sqrt(2*np.pi) * sigma) * np.exp(-z**2/(2*sigma**2))


def twoD2threeD(arr2d:np.ndarray, scale_height:np.ndarray, zvect:np.ndarray) -> np.ndarray:
    '''Convert surface density 2d array into volumic density 3d
    cylindrical array assuming a gaussian vertical distribution.

    formats
    arr2d : (nr, nphi)
    arr3d : (nr, nz, nphi) (suited for mcfost)

    note
    MCFOST offers the possibility to use a spherical grid instead.
    '''
    #devnote : gaussian distribution of dust is a bad fit.
    #For better modelization, see
    #eq 1 from (Pinte et al 2008) and eq 25 from (Fromang & Nelson 2009)

    nrad, nphi = arr2d.shape
    nz = len(zvect)
    arr3d = np.ones((nrad, nz, nphi))

    for k,z in enumerate(zvect):
        arr3d[:,k,:] = arr2d[:,:] * gauss(z, sigma=scale_height)
    return arr3d


mcfost_args_locate = {
    # locate mcfost arguments in default.para by (line,column)
    # grid
    'nr'   : (15,0),
    'nz'   : (15,1),
    'nphi' : (15,2),
    'nr_in': (15,3),
    'rmin' : (47,0),
    'rmax' : (47,2),
    'maps_size': (18,2),
    # dust
    'total_dust_mass': (45,0), #in solar masses
    'gas2dust_ratio' : (45,1),
    # star
    'distance': (21,0),
    'star_temp': (70,0),
    'star_mass': (70,2),
    # density
    'scale_height': (46,0),
    'ref_rad': (46,1), # where 'scale_height' is defined
    'flaring': (48,0),
}

def update_lines(lines, params:dict):
    for key,val in params.items():
        try:
            pos = mcfost_args_locate[key]
            mline = lines[pos[0]].split()
            mline[pos[1]] = str(val)
            lines[pos[0]] = '  ' + ' '.join(mline) + '\n'
        except KeyError:
            warn(f'unable to locate {key}')


def write_mcfost_conf(mcfost_list, mesh_list):
    with open(pathlib.Path(__file__).parent/'data/default_mcfost_conf.para', 'r') as fi:
        lines = fi.readlines()

    clines = lines[:] #copy
    update_lines(clines, mcfost_list)

    auto_fills = {
        'rmin': mesh_list['xprobmin1'],
        'rmax': mesh_list['xprobmax1'],
        'maps_size': 2*mesh_list['xprobmax1']
    }
    update_lines(clines, auto_fills)

    mcfost_conf_file = pathlib.Path('mcfost_conf.para')
    if mcfost_conf_file.exists():
        warn(f'{mcfost_conf_file} already exists, and will be overwritten.')
    with open(mcfost_conf_file, 'w') as fo:
        fo.write(''.join(clines))
        fo.write(f'\n\n\n%% GENERATED BY {__file__} %%\n')

def get_target_grid(mcfost_list, mesh_list, silent=True):
    '''pre-run McFost in -disk_struct mode to extract the exact grid used.'''
    if silent:
        stdout = subprocess.PIPE
    else:
        stdout = None
    write_mcfost_conf(mcfost_list, mesh_list)
    # generate a grid data file with mcfost itself and extract it
    tmp_fost_dir = pathlib.Path('tmp_mcfost')
    if tmp_fost_dir.exists():
        shutil.rmtree(tmp_fost_dir)
    try:
        subprocess.call(
            f'mcfost mcfost_conf.para -disk_struct -root_dir {tmp_fost_dir}',
            shell=True,
            stdout=stdout
        )
        target_grid = pyfits.open(tmp_fost_dir/'data_disk/grid.fits.gz')[0].data
    finally:
        shutil.rmtree(tmp_fost_dir)
    return target_grid

def get_grain_micron_sizes(dust_list) -> np.ndarray:
    '''Read grain sizes (assumed in [cm]), from AMRVAC parameters and
    convert to microns.'''
    #only works with one dust size for now
    #gas is not taken into account either !
    cm_sizes = np.array(dust_list['grain_size'])
    µm_sizes = 1e4 * cm_sizes
    #gas_grain = min(min(µm_sizes)/10, 1e-9)
    #µm_sizes.insert(0, gas_grain) #add a fake grain size to represent the gas
    return µm_sizes


def get_dat_from_blk(blk_file:str):
    '''Extract the data as a numpy array, ignoring weirdly shaped header.'''
    with open(blk_file, 'r') as blk:
    # pre-read the .blk output to learn where the actual data is written
        n_trash_lines = 0
        line = blk.readline()
        columns = line.split()[1:]
        densities_indices = [columns.index(key) for key in columns if 'rho' in key.lower()]
        if len(densities_indices) == 1:
            warn('only one density field detected (no dust) !')
        elif len(densities_indices) > 2:
            warn('this case has not been tested yet')
            #densities_indices = densities_indices[1:] #tmp

        while line.startswith('#') or line=='' or len(line.split())==1:
            n_trash_lines += 1
            line = blk.readline()

    blk_dat = np.loadtxt(blk_file, skiprows=n_trash_lines)
    return blk_dat, densities_indices


def main(config_file, offset:int=None, output_dir:str='.', dbg=False):
    print('==========================================')
    print(          'Starting vac2fost.main()')
    print('==========================================')

    # .. input reading ..

    config = f90nml.read(config_file)

    if type(config['fork_options']['conf']) == str:
        config['fork_options']['conf'] = [config['fork_options']['conf']]

    if offset is None:
        offset = config['target_options']['offset']
    outnum = str(offset).zfill(4)

    if isinstance(output_dir, str):
        output_dir = pathlib.Path(output_dir)

    sim, blk_finame = amrvac_convert(
        fork_args=config['fork_options'],
        outnum=outnum,
        target_dir=output_dir,
        ext='blk',
        dbg=dbg
    )

    # .. data reading and formating ..

    target_grid = get_target_grid(
        mcfost_list=config['mcfost_list'],
        mesh_list=sim.conf['meshlist'],
        silent=(not dbg)
    )

    block_dat, densities_indices = get_dat_from_blk(blk_finame)

    n_rad = sim.conf['meshlist']['domain_nx1']
    n_phi = sim.conf['meshlist']['domain_nx2']

    sorted_data     = sort_raw_data(block=block_dat, nr=n_rad, nphi=n_phi)
    reshaped_data   = [sorted_data[:,i].reshape((n_phi, n_rad)).T for i in range(sorted_data.shape[1])]
    reshaped_arrays = [reshaped_data[i] for i in densities_indices]

    # .. interpolation to new grid ..

    rad_vect  = unique_sorted_list(block_dat[:,0])
    azim_vect = unique_sorted_list(block_dat[:,1])
    assert len(rad_vect)  == n_rad
    assert len(azim_vect) == n_phi

    rad_grid_new = target_grid[0,:,0,:].T
    phi_grid_new = target_grid[2,:,0,:].T


    # define the target grid to interpolate data
    n_rad_new, n_phi_new = rad_grid_new.shape
    assert n_rad_new == config['mcfost_list']['nr']
    assert n_phi_new == config['mcfost_list']['nphi']

    rad_vect_new = rad_grid_new[:,0]
    phi_vect_new = phi_grid_new[0]

    interpolated_arrays = []
    for arr in reshaped_arrays:
        interpolator = interp2d(azim_vect, rad_vect, arr, kind='cubic')
        interpolated_arrays.append(interpolator(phi_vect_new, rad_vect_new))
    assert interpolated_arrays[0].shape == (n_rad_new, n_phi_new)


    # .. conversion to 3D ..

    zmax = config['target_options']['zmax']

    nz = config['mcfost_list']['nz']
    z_vect = np.linspace(-zmax, zmax, 2*nz+1)
    scale_height_grid = config['target_options']['aspect_ratio'] * rad_grid_new
    threeD_arrays = np.array([twoD2threeD(arr, scale_height_grid, z_vect) for arr in interpolated_arrays])



    # .. build a .fits file ..

    grain_sizes = get_grain_micron_sizes(sim.conf['usr_dust_list'])
    assert len(grain_sizes) == len(threeD_arrays) - 1

    #the transposition is handling a weird behavior of fits files...
    final_array = np.stack(threeD_arrays[grain_sizes.argsort()], axis=3).transpose()

    densitiesHDU = pyfits.PrimaryHDU(final_array)
    mcfost_keywords = {
        'read_n_a': 0, #automatic normalization of size-bins from mcfost param file.
        # following keywords are too long according to fits standards  !
        # --------------------------------------------------------------
        #'read_gas_density': 0, #set to 1 to add gas density
        #'gas_to_dust': sim.conf['usr_dust_list']['gas2dust_ratio'], #required when reading gas
    }

    for it in mcfost_keywords.items():
        densitiesHDU.header.append(it)

    grain_sizesHDU = pyfits.ImageHDU(grain_sizes[grain_sizes.argsort()])

    hdus = [
        densitiesHDU,
        grain_sizesHDU,
        #pyfits.ImageHDU(gas_density)
    ]
    fits_finame = output_dir / blk_finame.name.replace('.blk', '.fits')
    with open(fits_finame, 'w') as fo:
        hdul = pyfits.HDUList(hdus=hdus)
        hdul.writeto(fo)
    print(f'Successfully wrote {fits_finame}')

    print('==========================================')
    print(          'End of vac2fost.main()')
    print('==========================================')
    # .. finally, yield some info back (for testing) ..

    return dict(
        finame = fits_finame,
        rads   = rad_grid_new.T,
        phis   = phi_grid_new.T,
    )




if __name__=='__main__':
    # Parse the script arguments
    parser = ArgumentParser()
    parser.add_argument(
        dest='configuration', type=str,
        help='configuration file (namelist) for this script'
    )
    parser.add_argument(
        '-o', dest='off', type=str,
        required=False,
        default=None,
        help='output number of the target .dat VAC output file to be converted'
    )
    parser.add_argument(
        '--debug',
        action='store_true',
        help='activate debug mode (verbose)'
    )
    script_args = parser.parse_args()

    main(
        config_file=script_args.configuration,
        offset=script_args.off,
        dbg=script_args.debug
    )
